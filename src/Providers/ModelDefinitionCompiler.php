<?php

namespace WebImage\Models\Providers;

use WebImage\Models\Defs\ModelDefinitionInterface;

class ModelDefinitionCompiler
{
    /**
     * Compile model definitions to a PHP file
     *
     * @param ModelDefinitionInterface[] $definitions
     * @param SourceFileMetadata[] $sourceFiles
     * @param string $outputPath
     */
    public function compile(array $definitions, array $sourceFiles, string $outputPath): void
    {
        $definitionsHash = $this->computeDefinitionsHash($definitions);

        $data = [
            'compiled_at' => (new \DateTime())->format(\DateTime::ATOM),
            'definitions_hash' => $definitionsHash,
            'source_files' => $this->serializeSourceFiles($sourceFiles),
            'definitions' => $this->serializeDefinitions($definitions),
        ];

        $php = "<?php\n\n";
        $php .= "// Auto-generated by ModelDefinitionCompiler\n";
        $php .= "// Generated at: {$data['compiled_at']}\n";
        $php .= "// DO NOT EDIT MANUALLY\n\n";
        $php .= "return " . var_export($data, true) . ";\n";

        $dir = dirname($outputPath);
        if (!is_dir($dir)) {
            mkdir($dir, 0755, true);
        }

        file_put_contents($outputPath, $php);
    }

    /**
     * Compute aggregate hash of all definitions
     */
    private function computeDefinitionsHash(array $definitions): string
    {
        $serialized = serialize($definitions);
        return hash('sha256', $serialized);
    }

    /**
     * @param SourceFileMetadata[] $sourceFiles
     */
    private function serializeSourceFiles(array $sourceFiles): array
    {
        $result = [];
        foreach ($sourceFiles as $metadata) {
            $result[$metadata->path] = [
                'hash' => $metadata->hash,
                'modified' => $metadata->modifiedAt->format(\DateTime::ATOM),
            ];
        }
        return $result;
    }

    /**
     * Convert ModelDefinition objects to arrays
     *
     * @param ModelDefinitionInterface[] $definitions
     */
    private function serializeDefinitions(array $definitions): array
    {
        $result = [];
        foreach ($definitions as $definition) {
            $result[$definition->getName()] = $this->serializeDefinition($definition);
        }
        return $result;
    }

    /**
     * Convert a single ModelDefinition to array representation
     */
    private function serializeDefinition(ModelDefinitionInterface $definition): array
    {
        $data = [
            'name'           => $definition->getName(),
            'plural'         => $definition->getPluralName(),
//            'primaryKey'     => $definition->getPrimaryKeys()->keys(),
//            'security'       => null, // $definition->getSecurity()
            'friendly'       => $definition->getFriendlyName(),
            'pluralFriendly' => $definition->getPluralFriendlyName(),
            'related'        => null,
            'properties'     => [],
        ];

        foreach ($definition->getProperties() as $property) {
            $propData = [
                'name' => $property->getName(),
                'type' => $property->getDataType()
            ];

            if (strlen($property->getFriendlyName()) > 0) {
                $propData['friendlyName'] = $property->getFriendlyName();
            }

            if (strlen($property->getComment()) > 0) {
                $propData['comment'] = $property->getComment();
            }

            if ($property->isMultiValued()) {
                $propData['multiple'] = true;
            }

            if ($property->getGenerationStrategy() !== null) {
                $propData['generationStrategy'] = $property->getGenerationStrategy();
            }

            // Add optional property attributes
            if ($property->isPrimaryKey()) {
                $propData['primaryKey'] = true;
            }

            if ($property->hasReference()) {
                $ref = $property->getReference();
                $propData['reference'] = [
                    'reverseProperty' => $ref->getReverseProperty(),
                    'selectProperty' => $ref->getSelectProperty(),
                    'targetModel' => $ref->getTargetModel()
                ];
            }

            if ($property->isRequired()) {
                $propData['required'] = true;
            }

            if ($property->getSize() != 0) {
                $propData['size'] = $property->getSize();
            }

            if ($property->getSize2() != 0) {
                $propData['size2'] = $property->getSize2();
            }

            if ($property->getDefault() !== null) {
                $propData['default'] = $property->getDefault();
            }

            $data['properties'][$property->getName()] = $propData;
        }

        return $data;
    }
}